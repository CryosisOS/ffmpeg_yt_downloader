In file included from main.cpp:7:
include/argparse.hpp:75:23: error: expected template-name before ‘<’ token
     : std::conjunction<std::is_constructible<std::string, T>,
                       ^
include/argparse.hpp:75:23: error: expected ‘{’ before ‘<’ token
include/argparse.hpp: In function ‘constexpr decltype(auto) argparse::details::apply_plus_one_impl(F&&, Tuple&&, Extra&&, std::index_sequence<I ...>)’:
include/argparse.hpp:81:15: error: ‘invoke’ is not a member of ‘std’
   return std::invoke(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...,
               ^~~~~~
include/argparse.hpp:81:15: note: suggested alternative: ‘ignore’
   return std::invoke(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...,
               ^~~~~~
               ignore
include/argparse.hpp: In function ‘constexpr decltype(auto) argparse::details::apply_plus_one(F&&, Tuple&&, Extra&&)’:
include/argparse.hpp:90:16: error: ‘tuple_size_v’ is not a member of ‘std’
           std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
                ^~~~~~~~~~~~
include/argparse.hpp:90:16: note: suggested alternative: ‘tuple_size’
           std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
                ^~~~~~~~~~~~
                tuple_size
include/argparse.hpp:90:16: error: ‘tuple_size_v’ is not a member of ‘std’
include/argparse.hpp:90:16: note: suggested alternative: ‘tuple_size’
           std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
                ^~~~~~~~~~~~
                tuple_size
include/argparse.hpp:90:58: error: template argument 1 is invalid
           std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
                                                          ^~
include/argparse.hpp:90:61: error: expected primary-expression before ‘{’ token
           std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
                                                             ^
include/argparse.hpp: At global scope:
include/argparse.hpp:118:22: error: ‘conjunction_v’ is not a member of ‘std’
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                      ^~~~~~~~~~~~~
include/argparse.hpp:118:22: note: suggested alternative: ‘function’
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                      ^~~~~~~~~~~~~
                      function
include/argparse.hpp:118:22: error: ‘conjunction_v’ is not a member of ‘std’
include/argparse.hpp:118:22: note: suggested alternative: ‘function’
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                      ^~~~~~~~~~~~~
                      function
include/argparse.hpp:118:65: error: expected parameter pack before ‘...’
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                                                                 ^~~
include/argparse.hpp:118:68: error: template argument 1 is invalid
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                                                                    ^
include/argparse.hpp:118:76: error: expected unqualified-id before ‘=’ token
                 std::conjunction_v<details::is_string_like<Args>...>, int> = 0>
                                                                            ^
include/argparse.hpp:120:60: error: expected unqualified-id before ‘,’ token
       : Argument({std::string(std::forward<Args>(args))...},
                                                            ^
include/argparse.hpp:121:61: error: expected unqualified-id before ‘)’ token
                  std::make_index_sequence<sizeof...(Args)>{}) {}
                                                             ^
include/argparse.hpp:128:13: error: expected ‘;’ at end of member declaration
   Argument &default_value(std::any aDefaultValue) {
             ^~~~~~~~~~~~~
                          ;
include/argparse.hpp:128:35: error: expected ‘)’ before ‘aDefaultValue’
   Argument &default_value(std::any aDefaultValue) {
                          ~        ^~~~~~~~~~~~~~
                                   )
include/argparse.hpp:138:13: error: expected ‘;’ at end of member declaration
   Argument &implicit_value(std::any aImplicitValue) {
             ^~~~~~~~~~~~~~
                           ;
include/argparse.hpp:138:36: error: expected ‘)’ before ‘aImplicitValue’
   Argument &implicit_value(std::any aImplicitValue) {
                           ~        ^~~~~~~~~~~~~~~
                                    )
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:76: error: template argument 1 is invalid
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                                                            ^
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:76: error: template argument 1 is invalid
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                                                            ^
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:76: error: template argument 1 is invalid
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                                                            ^
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:76: error: template argument 1 is invalid
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                                                            ^
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:32: error: ‘is_invocable_v’ is not a member of ‘std’
include/argparse.hpp:146:32: note: suggested alternative: ‘is_swappable_v’
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                ^~~~~~~~~~~~~~
                                is_swappable_v
include/argparse.hpp:146:76: error: template argument 1 is invalid
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                                                                            ^
include/argparse.hpp:146:10: error: invalid use of template-name ‘std::enable_if_t’ without an argument list
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
          ^~~
In file included from /usr/include/c++/8/bits/move.h:55,
                 from /usr/include/c++/8/bits/stl_pair.h:59,
                 from /usr/include/c++/8/utility:70,
                 from /usr/include/c++/8/algorithm:60,
                 from include/argparse.hpp:31,
                 from main.cpp:7:
/usr/include/c++/8/type_traits:2294:61: note: ‘template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type’ declared here
     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                                             ^
In file included from main.cpp:7:
include/argparse.hpp:146:26: error: expected initializer before ‘<’ token
       -> std::enable_if_t<std::is_invocable_v<F, Args..., std::string const>,
                          ^
include/argparse.hpp:254:36: error: ‘optional’ in namespace ‘std’ does not name a template type
   auto maybe_nargs() const -> std::optional<size_t> {
                                    ^~~~~~~~
include/argparse.hpp:254:31: note: ‘std::optional’ is only available from C++17 onwards
   auto maybe_nargs() const -> std::optional<size_t> {
                               ^~~
include/argparse.hpp:254:36: error: expected ‘;’ at end of member declaration
   auto maybe_nargs() const -> std::optional<size_t> {
                                    ^~~~~~~~
                                            ;
include/argparse.hpp:254:44: error: expected unqualified-id before ‘<’ token
   auto maybe_nargs() const -> std::optional<size_t> {
                                            ^
include/argparse.hpp:350:57: error: ‘any’ is not a member of ‘std’
   static auto any_cast_container(const std::vector<std::any> &aOperand) -> T {
                                                         ^~~
include/argparse.hpp:350:57: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:350:57: error: ‘any’ is not a member of ‘std’
include/argparse.hpp:350:57: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:350:60: error: template argument 1 is invalid
   static auto any_cast_container(const std::vector<std::any> &aOperand) -> T {
                                                            ^
include/argparse.hpp:350:60: error: template argument 2 is invalid
include/argparse.hpp:363:8: error: ‘any’ in namespace ‘std’ does not name a type
   std::any mDefaultValue;
        ^~~
include/argparse.hpp:363:3: note: ‘std::any’ is only available from C++17 onwards
   std::any mDefaultValue;
   ^~~
include/argparse.hpp:364:8: error: ‘any’ in namespace ‘std’ does not name a type
   std::any mImplicitValue;
        ^~~
include/argparse.hpp:364:3: note: ‘std::any’ is only available from C++17 onwards
   std::any mImplicitValue;
   ^~~
include/argparse.hpp:365:44: error: ‘any’ is not a member of ‘std’
   using valued_action = std::function<std::any(const std::string &)>;
                                            ^~~
include/argparse.hpp:365:44: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:365:44: error: ‘any’ is not a member of ‘std’
include/argparse.hpp:365:44: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:365:68: error: template argument 1 is invalid
   using valued_action = std::function<std::any(const std::string &)>;
                                                                    ^
include/argparse.hpp:367:8: error: ‘variant’ in namespace ‘std’ does not name a template type
   std::variant<valued_action, void_action> mAction{
        ^~~~~~~
include/argparse.hpp:367:3: note: ‘std::variant’ is only available from C++17 onwards
   std::variant<valued_action, void_action> mAction{
   ^~~
include/argparse.hpp:370:20: error: ‘any’ is not a member of ‘std’
   std::vector<std::any> mValues;
                    ^~~
include/argparse.hpp:370:20: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:370:20: error: ‘any’ is not a member of ‘std’
include/argparse.hpp:370:20: note: ‘std::any’ is only available from C++17 onwards
include/argparse.hpp:370:23: error: template argument 1 is invalid
   std::vector<std::any> mValues;
                       ^
include/argparse.hpp:370:23: error: template argument 2 is invalid
include/argparse.hpp: In constructor ‘argparse::Argument::Argument(std::__cxx11::string (&&)[N], std::index_sequence<I ...>)’:
include/argparse.hpp:104:43: warning: fold-expressions only available with -std=c++17 or -std=gnu++17
       : mIsOptional((is_optional(a[I]) || ...)), mIsRequired(false),
                                           ^~~
include/argparse.hpp:106:47: warning: fold-expressions only available with -std=c++17 or -std=gnu++17
     ((void)mNames.push_back(std::move(a[I])), ...);
                                               ^~~
include/argparse.hpp: In member function ‘Iterator argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string)’:
include/argparse.hpp:183:15: error: request for member ‘emplace_back’ in ‘((argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘int’
       mValues.emplace_back(mImplicitValue);
               ^~~~~~~~~~~~
include/argparse.hpp:183:28: error: ‘mImplicitValue’ was not declared in this scope
       mValues.emplace_back(mImplicitValue);
                            ^~~~~~~~~~~~~~
include/argparse.hpp:183:28: note: suggested alternative: ‘implicit_value’
       mValues.emplace_back(mImplicitValue);
                            ^~~~~~~~~~~~~~
                            implicit_value
include/argparse.hpp:186:27: error: there are no arguments to ‘maybe_nargs’ that depend on a template parameter, so a declaration of ‘maybe_nargs’ must be available [-fpermissive]
       if (auto expected = maybe_nargs()) {
                           ^~~~~~~~~~~
include/argparse.hpp:186:27: note: (if you use ‘-fpermissive’, G++ will accept your code, but allowing the use of an undeclared name is deprecated)
include/argparse.hpp:194:25: error: ‘valued_action’ has not been declared
         void operator()(valued_action &f) {
                         ^~~~~~~~~~~~~
include/argparse.hpp: In member function ‘void argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string)::action_apply::operator()(argparse::Argument::void_action&)’:
include/argparse.hpp:200:21: error: ‘class argparse::Argument’ has no member named ‘mDefaultValue’; did you mean ‘default_value’?
           if (!self.mDefaultValue.has_value()) {
                     ^~~~~~~~~~~~~
                     default_value
include/argparse.hpp:201:38: error: ‘class argparse::Argument’ has no member named ‘maybe_nargs’
             if (auto expected = self.maybe_nargs())
                                      ^~~~~~~~~~~
include/argparse.hpp:202:28: error: request for member ‘resize’ in ‘((argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string)::action_apply*)this)->argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string)::action_apply::self.mValues’, which is of non-class type ‘int’
               self.mValues.resize(*expected);
                            ^~~~~~
include/argparse.hpp: In member function ‘Iterator argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string)’:
include/argparse.hpp:209:12: error: ‘visit’ is not a member of ‘std’
       std::visit(action_apply{start, end, *this}, mAction);
            ^~~~~
include/argparse.hpp:209:12: note: ‘std::visit’ is only available from C++17 onwards
include/argparse.hpp:209:51: error: ‘mAction’ was not declared in this scope
       std::visit(action_apply{start, end, *this}, mAction);
                                                   ^~~~~~~
include/argparse.hpp:211:16: error: ‘mDefaultValue’ was not declared in this scope
     } else if (mDefaultValue.has_value()) {
                ^~~~~~~~~~~~~
include/argparse.hpp:211:16: note: suggested alternative: ‘default_value’
     } else if (mDefaultValue.has_value()) {
                ^~~~~~~~~~~~~
                default_value
include/argparse.hpp: In member function ‘void argparse::Argument::validate() const’:
include/argparse.hpp:222:25: error: ‘maybe_nargs’ was not declared in this scope
     if (auto expected = maybe_nargs()) {
                         ^~~~~~~~~~~
include/argparse.hpp:224:32: error: request for member ‘size’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
         if (mIsUsed && mValues.size() != *expected &&
                                ^~~~
include/argparse.hpp:225:14: error: ‘mDefaultValue’ was not declared in this scope
             !mDefaultValue.has_value()) {
              ^~~~~~~~~~~~~
include/argparse.hpp:225:14: note: suggested alternative: ‘default_value’
             !mDefaultValue.has_value()) {
              ^~~~~~~~~~~~~
              default_value
include/argparse.hpp:228:29: error: request for member ‘size’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
                  << mValues.size() << " provided.";
                             ^~~~
include/argparse.hpp:237:49: error: request for member ‘size’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
           if (mIsUsed && mIsRequired && mValues.size() == 0) {
                                                 ^~~~
include/argparse.hpp:244:21: error: request for member ‘size’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
         if (mValues.size() != expected && !mDefaultValue.has_value()) {
                     ^~~~
include/argparse.hpp:244:44: error: ‘mDefaultValue’ was not declared in this scope
         if (mValues.size() != expected && !mDefaultValue.has_value()) {
                                            ^~~~~~~~~~~~~
include/argparse.hpp:244:44: note: suggested alternative: ‘default_value’
         if (mValues.size() != expected && !mDefaultValue.has_value()) {
                                            ^~~~~~~~~~~~~
                                            default_value
include/argparse.hpp:247:29: error: request for member ‘size’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
                  << mValues.size() << " provided.";
                             ^~~~
include/argparse.hpp: In member function ‘bool argparse::Argument::operator==(const T&) const’:
include/argparse.hpp:290:8: warning: ‘if constexpr’ only available with -std=c++17 or -std=gnu++17
     if constexpr (!details::is_container_v<T>) {
        ^~~~~~~~~
include/argparse.hpp: In lambda function:
include/argparse.hpp:297:39: error: ‘any_cast’ is not a member of ‘std’
                           return std::any_cast<const ValueType &>(lhs) == rhs;
                                       ^~~~~~~~
include/argparse.hpp:297:39: note: ‘std::any_cast’ is only available from C++17 onwards
include/argparse.hpp:297:48: error: expected primary-expression before ‘const’
                           return std::any_cast<const ValueType &>(lhs) == rhs;
                                                ^~~~~
include/argparse.hpp:297:48: error: expected ‘;’ before ‘const’
                           return std::any_cast<const ValueType &>(lhs) == rhs;
                                                ^~~~~
                                                ;
include/argparse.hpp:297:65: error: expected unqualified-id before ‘>’ token
                           return std::any_cast<const ValueType &>(lhs) == rhs;
                                                                 ^
include/argparse.hpp: In member function ‘T argparse::Argument::get() const’:
include/argparse.hpp:337:18: error: request for member ‘empty’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
     if (!mValues.empty()) {
                  ^~~~~
include/argparse.hpp:338:10: warning: ‘if constexpr’ only available with -std=c++17 or -std=gnu++17
       if constexpr (details::is_container_v<T>)
          ^~~~~~~~~
include/argparse.hpp:341:21: error: ‘any_cast’ is not a member of ‘std’
         return std::any_cast<T>(mValues.front());
                     ^~~~~~~~
include/argparse.hpp:341:21: note: ‘std::any_cast’ is only available from C++17 onwards
include/argparse.hpp:341:31: error: expected primary-expression before ‘>’ token
         return std::any_cast<T>(mValues.front());
                               ^
include/argparse.hpp:341:41: error: request for member ‘front’ in ‘((const argparse::Argument*)this)->argparse::Argument::mValues’, which is of non-class type ‘const int’
         return std::any_cast<T>(mValues.front());
                                         ^~~~~
include/argparse.hpp:343:9: error: ‘mDefaultValue’ was not declared in this scope
     if (mDefaultValue.has_value()) {
         ^~~~~~~~~~~~~
include/argparse.hpp:343:9: note: suggested alternative: ‘default_value’
     if (mDefaultValue.has_value()) {
         ^~~~~~~~~~~~~
         default_value
include/argparse.hpp:344:19: error: ‘any_cast’ is not a member of ‘std’
       return std::any_cast<T>(mDefaultValue);
                   ^~~~~~~~
include/argparse.hpp:344:19: note: ‘std::any_cast’ is only available from C++17 onwards
include/argparse.hpp:344:29: error: expected primary-expression before ‘>’ token
       return std::any_cast<T>(mDefaultValue);
                             ^
include/argparse.hpp: In static member function ‘static T argparse::Argument::any_cast_container(const int&)’:
include/argparse.hpp:355:9: error: there are no arguments to ‘begin’ that depend on a template parameter, so a declaration of ‘begin’ must be available [-fpermissive]
         begin(aOperand), end(aOperand), std::back_inserter(tResult),
         ^~~~~
include/argparse.hpp:355:26: error: there are no arguments to ‘end’ that depend on a template parameter, so a declaration of ‘end’ must be available [-fpermissive]
         begin(aOperand), end(aOperand), std::back_inserter(tResult),
                          ^~~
include/argparse.hpp: In lambda function:
include/argparse.hpp:356:45: error: ‘any_cast’ is not a member of ‘std’
         [](const auto &value) { return std::any_cast<ValueType>(value); });
                                             ^~~~~~~~
include/argparse.hpp:356:45: note: ‘std::any_cast’ is only available from C++17 onwards
include/argparse.hpp:356:63: error: expected primary-expression before ‘>’ token
         [](const auto &value) { return std::any_cast<ValueType>(value); });
                                                               ^
include/argparse.hpp: At global scope:
include/argparse.hpp:467:50: error: ‘std::string_view’ has not been declared
   template <typename T = std::string> T get(std::string_view aArgumentName) {
                                                  ^~~~~~~~~~~
include/argparse.hpp:475:29: error: declaration of ‘operator[]’ as non-function
   Argument &operator[](std::string_view aArgumentName) {
                             ^~~~~~~~~~~
include/argparse.hpp:475:22: error: expected ‘;’ at end of member declaration
   Argument &operator[](std::string_view aArgumentName) {
                      ^
                       ;
include/argparse.hpp:475:40: error: expected ‘)’ before ‘aArgumentName’
   Argument &operator[](std::string_view aArgumentName) {
                       ~                ^~~~~~~~~~~~~~
                                        )
include/argparse.hpp:616:17: error: ‘string_view’ is not a member of ‘std’
   std::map<std::string_view, list_iterator, std::less<>> mArgumentMap;
                 ^~~~~~~~~~~
include/argparse.hpp:616:17: note: ‘std::string_view’ is only available from C++17 onwards
include/argparse.hpp:616:17: error: ‘string_view’ is not a member of ‘std’
include/argparse.hpp:616:17: note: ‘std::string_view’ is only available from C++17 onwards
include/argparse.hpp:616:55: error: template argument 1 is invalid
   std::map<std::string_view, list_iterator, std::less<>> mArgumentMap;
                                                       ^~
include/argparse.hpp:616:55: error: template argument 4 is invalid
include/argparse.hpp: In constructor ‘argparse::ArgumentParser::ArgumentParser(std::__cxx11::string)’:
include/argparse.hpp:387:29: error: no match for call to ‘(argparse::Argument) (bool)’
         .default_value(false)
                             ^
include/argparse.hpp: In member function ‘T argparse::ArgumentParser::get(int)’:
include/argparse.hpp:468:19: error: no match for ‘operator[]’ (operand types are ‘argparse::ArgumentParser’ and ‘int’)
     return (*this)[aArgumentName].get<T>();
                   ^
include/argparse.hpp:468:40: error: expected primary-expression before ‘>’ token
     return (*this)[aArgumentName].get<T>();
                                        ^
include/argparse.hpp:468:42: error: expected primary-expression before ‘)’ token
     return (*this)[aArgumentName].get<T>();
                                          ^
include/argparse.hpp: In member function ‘void argparse::ArgumentParser::parse_args_internal(const std::vector<std::__cxx11::basic_string<char> >&)’:
include/argparse.hpp:556:18: warning: init-statement in selection statements only available with -std=c++17 or -std=gnu++17
       } else if (auto tIterator = mArgumentMap.find(tCurrentArgument);
                  ^~~~
include/argparse.hpp:556:48: error: request for member ‘find’ in ‘((argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘int’
       } else if (auto tIterator = mArgumentMap.find(tCurrentArgument);
                                                ^~~~
include/argparse.hpp:557:44: error: request for member ‘end’ in ‘((argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘int’
                  tIterator != mArgumentMap.end()) {
                                            ^~~
include/argparse.hpp:560:18: warning: init-statement in selection statements only available with -std=c++17 or -std=gnu++17
       } else if (const auto &tCompoundArgument = tCurrentArgument;
                  ^~~~~
include/argparse.hpp:566:42: error: request for member ‘find’ in ‘((argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘int’
           auto tIterator2 = mArgumentMap.find(tHypotheticalArgument);
                                          ^~~~
include/argparse.hpp:567:42: error: request for member ‘end’ in ‘((argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘int’
           if (tIterator2 != mArgumentMap.end()) {
                                          ^~~
include/argparse.hpp: In member function ‘void argparse::ArgumentParser::parse_args_validate()’:
include/argparse.hpp:585:42: error: no matching function for call to ‘begin(int&)’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                          ^
In file included from /usr/include/c++/8/utility:76,
                 from /usr/include/c++/8/algorithm:60,
                 from include/argparse.hpp:31,
                 from main.cpp:7:
/usr/include/c++/8/initializer_list:89:5: note: candidate: ‘template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)’
     begin(initializer_list<_Tp> __ils) noexcept
     ^~~~~
/usr/include/c++/8/initializer_list:89:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:42: note:   mismatched types ‘std::initializer_list<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                          ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:48:5: note: candidate: ‘template<class _Container> decltype (__cont.begin()) std::begin(_Container&)’
     begin(_Container& __cont) -> decltype(__cont.begin())
     ^~~~~
/usr/include/c++/8/bits/range_access.h:48:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.begin()) std::begin(_Container&) [with _Container = int]’:
include/argparse.hpp:585:42:   required from here
/usr/include/c++/8/bits/range_access.h:48:50: error: request for member ‘begin’ in ‘__cont’, which is of non-class type ‘int’
     begin(_Container& __cont) -> decltype(__cont.begin())
                                           ~~~~~~~^~~~~
/usr/include/c++/8/bits/range_access.h:58:5: note: candidate: ‘template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)’
     begin(const _Container& __cont) -> decltype(__cont.begin())
     ^~~~~
/usr/include/c++/8/bits/range_access.h:58:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.begin()) std::begin(const _Container&) [with _Container = int]’:
include/argparse.hpp:585:42:   required from here
/usr/include/c++/8/bits/range_access.h:58:56: error: request for member ‘begin’ in ‘__cont’, which is of non-class type ‘const int’
     begin(const _Container& __cont) -> decltype(__cont.begin())
                                                 ~~~~~~~^~~~~
/usr/include/c++/8/bits/range_access.h:87:5: note: candidate: ‘template<class _Tp, long unsigned int _Nm> constexpr _Tp* std::begin(_Tp (&)[_Nm])’
     begin(_Tp (&__arr)[_Nm])
     ^~~~~
/usr/include/c++/8/bits/range_access.h:87:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:42: note:   mismatched types ‘_Tp [_Nm]’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                          ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:104:31: note: candidate: ‘template<class _Tp> _Tp* std::begin(std::valarray<_Tp>&)’
   template<typename _Tp> _Tp* begin(valarray<_Tp>&);
                               ^~~~~
/usr/include/c++/8/bits/range_access.h:104:31: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:42: note:   mismatched types ‘std::valarray<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                          ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:105:37: note: candidate: ‘template<class _Tp> const _Tp* std::begin(const std::valarray<_Tp>&)’
   template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
                                     ^~~~~
/usr/include/c++/8/bits/range_access.h:105:37: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:42: note:   mismatched types ‘const std::valarray<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                          ^
include/argparse.hpp:585:66: error: no matching function for call to ‘end(int&)’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                  ^
In file included from /usr/include/c++/8/utility:76,
                 from /usr/include/c++/8/algorithm:60,
                 from include/argparse.hpp:31,
                 from main.cpp:7:
/usr/include/c++/8/initializer_list:99:5: note: candidate: ‘template<class _Tp> constexpr const _Tp* std::end(std::initializer_list<_Tp>)’
     end(initializer_list<_Tp> __ils) noexcept
     ^~~
/usr/include/c++/8/initializer_list:99:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:66: note:   mismatched types ‘std::initializer_list<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                  ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:68:5: note: candidate: ‘template<class _Container> decltype (__cont.end()) std::end(_Container&)’
     end(_Container& __cont) -> decltype(__cont.end())
     ^~~
/usr/include/c++/8/bits/range_access.h:68:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.end()) std::end(_Container&) [with _Container = int]’:
include/argparse.hpp:585:66:   required from here
/usr/include/c++/8/bits/range_access.h:68:48: error: request for member ‘end’ in ‘__cont’, which is of non-class type ‘int’
     end(_Container& __cont) -> decltype(__cont.end())
                                         ~~~~~~~^~~
/usr/include/c++/8/bits/range_access.h:78:5: note: candidate: ‘template<class _Container> decltype (__cont.end()) std::end(const _Container&)’
     end(const _Container& __cont) -> decltype(__cont.end())
     ^~~
/usr/include/c++/8/bits/range_access.h:78:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.end()) std::end(const _Container&) [with _Container = int]’:
include/argparse.hpp:585:66:   required from here
/usr/include/c++/8/bits/range_access.h:78:54: error: request for member ‘end’ in ‘__cont’, which is of non-class type ‘const int’
     end(const _Container& __cont) -> decltype(__cont.end())
                                               ~~~~~~~^~~
/usr/include/c++/8/bits/range_access.h:97:5: note: candidate: ‘template<class _Tp, long unsigned int _Nm> constexpr _Tp* std::end(_Tp (&)[_Nm])’
     end(_Tp (&__arr)[_Nm])
     ^~~
/usr/include/c++/8/bits/range_access.h:97:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:66: note:   mismatched types ‘_Tp [_Nm]’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                  ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:106:31: note: candidate: ‘template<class _Tp> _Tp* std::end(std::valarray<_Tp>&)’
   template<typename _Tp> _Tp* end(valarray<_Tp>&);
                               ^~~
/usr/include/c++/8/bits/range_access.h:106:31: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:66: note:   mismatched types ‘std::valarray<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                  ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:107:37: note: candidate: ‘template<class _Tp> const _Tp* std::end(const std::valarray<_Tp>&)’
   template<typename _Tp> const _Tp* end(const valarray<_Tp>&);
                                     ^~~
/usr/include/c++/8/bits/range_access.h:107:37: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:585:66: note:   mismatched types ‘const std::valarray<_Tp>’ and ‘int’
     std::for_each(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                  ^
include/argparse.hpp: In member function ‘size_t argparse::ArgumentParser::get_length_of_longest_argument() const’:
include/argparse.hpp:594:22: error: request for member ‘empty’ in ‘((const argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘const int’
     if (mArgumentMap.empty())
                      ^~~~~
include/argparse.hpp:596:54: error: request for member ‘size’ in ‘((const argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘const int’
     std::vector<size_t> argumentLengths(mArgumentMap.size());
                                                      ^~~~
include/argparse.hpp:597:43: error: no matching function for call to ‘begin(const int&)’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                           ^
In file included from /usr/include/c++/8/utility:76,
                 from /usr/include/c++/8/algorithm:60,
                 from include/argparse.hpp:31,
                 from main.cpp:7:
/usr/include/c++/8/initializer_list:89:5: note: candidate: ‘template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)’
     begin(initializer_list<_Tp> __ils) noexcept
     ^~~~~
/usr/include/c++/8/initializer_list:89:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:43: note:   mismatched types ‘std::initializer_list<_Tp>’ and ‘int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                           ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:48:5: note: candidate: ‘template<class _Container> decltype (__cont.begin()) std::begin(_Container&)’
     begin(_Container& __cont) -> decltype(__cont.begin())
     ^~~~~
/usr/include/c++/8/bits/range_access.h:48:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.begin()) std::begin(_Container&) [with _Container = const int]’:
include/argparse.hpp:597:43:   required from here
/usr/include/c++/8/bits/range_access.h:48:50: error: request for member ‘begin’ in ‘__cont’, which is of non-class type ‘const int’
     begin(_Container& __cont) -> decltype(__cont.begin())
                                           ~~~~~~~^~~~~
/usr/include/c++/8/bits/range_access.h:58:5: note: candidate: ‘template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)’
     begin(const _Container& __cont) -> decltype(__cont.begin())
     ^~~~~
/usr/include/c++/8/bits/range_access.h:58:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.begin()) std::begin(const _Container&) [with _Container = int]’:
include/argparse.hpp:597:43:   required from here
/usr/include/c++/8/bits/range_access.h:58:56: error: request for member ‘begin’ in ‘__cont’, which is of non-class type ‘const int’
     begin(const _Container& __cont) -> decltype(__cont.begin())
                                                 ~~~~~~~^~~~~
/usr/include/c++/8/bits/range_access.h:87:5: note: candidate: ‘template<class _Tp, long unsigned int _Nm> constexpr _Tp* std::begin(_Tp (&)[_Nm])’
     begin(_Tp (&__arr)[_Nm])
     ^~~~~
/usr/include/c++/8/bits/range_access.h:87:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:43: note:   mismatched types ‘_Tp [_Nm]’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                           ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:104:31: note: candidate: ‘template<class _Tp> _Tp* std::begin(std::valarray<_Tp>&)’
   template<typename _Tp> _Tp* begin(valarray<_Tp>&);
                               ^~~~~
/usr/include/c++/8/bits/range_access.h:104:31: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:43: note:   mismatched types ‘std::valarray<_Tp>’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                           ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:105:37: note: candidate: ‘template<class _Tp> const _Tp* std::begin(const std::valarray<_Tp>&)’
   template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
                                     ^~~~~
/usr/include/c++/8/bits/range_access.h:105:37: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:43: note:   mismatched types ‘const std::valarray<_Tp>’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                           ^
include/argparse.hpp:597:67: error: no matching function for call to ‘end(const int&)’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                   ^
In file included from /usr/include/c++/8/utility:76,
                 from /usr/include/c++/8/algorithm:60,
                 from include/argparse.hpp:31,
                 from main.cpp:7:
/usr/include/c++/8/initializer_list:99:5: note: candidate: ‘template<class _Tp> constexpr const _Tp* std::end(std::initializer_list<_Tp>)’
     end(initializer_list<_Tp> __ils) noexcept
     ^~~
/usr/include/c++/8/initializer_list:99:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:67: note:   mismatched types ‘std::initializer_list<_Tp>’ and ‘int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                   ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:68:5: note: candidate: ‘template<class _Container> decltype (__cont.end()) std::end(_Container&)’
     end(_Container& __cont) -> decltype(__cont.end())
     ^~~
/usr/include/c++/8/bits/range_access.h:68:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.end()) std::end(_Container&) [with _Container = const int]’:
include/argparse.hpp:597:67:   required from here
/usr/include/c++/8/bits/range_access.h:68:48: error: request for member ‘end’ in ‘__cont’, which is of non-class type ‘const int’
     end(_Container& __cont) -> decltype(__cont.end())
                                         ~~~~~~~^~~
/usr/include/c++/8/bits/range_access.h:78:5: note: candidate: ‘template<class _Container> decltype (__cont.end()) std::end(const _Container&)’
     end(const _Container& __cont) -> decltype(__cont.end())
     ^~~
/usr/include/c++/8/bits/range_access.h:78:5: note:   template argument deduction/substitution failed:
/usr/include/c++/8/bits/range_access.h: In substitution of ‘template<class _Container> decltype (__cont.end()) std::end(const _Container&) [with _Container = int]’:
include/argparse.hpp:597:67:   required from here
/usr/include/c++/8/bits/range_access.h:78:54: error: request for member ‘end’ in ‘__cont’, which is of non-class type ‘const int’
     end(const _Container& __cont) -> decltype(__cont.end())
                                               ~~~~~~~^~~
/usr/include/c++/8/bits/range_access.h:97:5: note: candidate: ‘template<class _Tp, long unsigned int _Nm> constexpr _Tp* std::end(_Tp (&)[_Nm])’
     end(_Tp (&__arr)[_Nm])
     ^~~
/usr/include/c++/8/bits/range_access.h:97:5: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:67: note:   mismatched types ‘_Tp [_Nm]’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                   ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:106:31: note: candidate: ‘template<class _Tp> _Tp* std::end(std::valarray<_Tp>&)’
   template<typename _Tp> _Tp* end(valarray<_Tp>&);
                               ^~~
/usr/include/c++/8/bits/range_access.h:106:31: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:67: note:   mismatched types ‘std::valarray<_Tp>’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                   ^
In file included from /usr/include/c++/8/string:51,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/bits/range_access.h:107:37: note: candidate: ‘template<class _Tp> const _Tp* std::end(const std::valarray<_Tp>&)’
   template<typename _Tp> const _Tp* end(const valarray<_Tp>&);
                                     ^~~
/usr/include/c++/8/bits/range_access.h:107:37: note:   template argument deduction/substitution failed:
In file included from main.cpp:7:
include/argparse.hpp:597:67: note:   mismatched types ‘const std::valarray<_Tp>’ and ‘const int’
     std::transform(std::begin(mArgumentMap), std::end(mArgumentMap),
                                                                   ^
include/argparse.hpp: In member function ‘void argparse::ArgumentParser::index_argument(argparse::ArgumentParser::list_iterator)’:
include/argparse.hpp:609:29: error: ‘as_const’ is not a member of ‘std’
     for (auto &mName : std::as_const(argIt->mNames))
                             ^~~~~~~~
include/argparse.hpp:609:29: note: suggested alternative: ‘is_const’
     for (auto &mName : std::as_const(argIt->mNames))
                             ^~~~~~~~
                             is_const
include/argparse.hpp:610:20: error: request for member ‘emplace’ in ‘((argparse::ArgumentParser*)this)->argparse::ArgumentParser::mArgumentMap’, which is of non-class type ‘int’
       mArgumentMap.emplace(mName, argIt);
                    ^~~~~~~
include/argparse.hpp: In instantiation of ‘Iterator argparse::Argument::consume(Iterator, Iterator, std::__cxx11::string) [with Iterator = __gnu_cxx::__normal_iterator<const std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char> > >; std::__cxx11::string = std::__cxx11::basic_string<char>]’:
include/argparse.hpp:555:40:   required from here
include/argparse.hpp:186:38: error: ‘maybe_nargs’ was not declared in this scope
       if (auto expected = maybe_nargs()) {
                           ~~~~~~~~~~~^~
In file included from /usr/include/x86_64-linux-gnu/c++/8/bits/c++allocator.h:33,
                 from /usr/include/c++/8/bits/allocator.h:46,
                 from /usr/include/c++/8/string:41,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/ext/new_allocator.h: In instantiation of ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = argparse::Argument; _Args = {const char*, const char*}; _Tp = std::_List_node<argparse::Argument>]’:
/usr/include/c++/8/bits/alloc_traits.h:475:4:   required from ‘static void std::allocator_traits<std::allocator<_Tp> >::construct(std::allocator_traits<std::allocator<_Tp> >::allocator_type&, _Up*, _Args&& ...) [with _Up = argparse::Argument; _Args = {const char*, const char*}; _Tp = std::_List_node<argparse::Argument>; std::allocator_traits<std::allocator<_Tp> >::allocator_type = std::allocator<std::_List_node<argparse::Argument> >]’
/usr/include/c++/8/bits/stl_list.h:645:33:   required from ‘std::__cxx11::list<_Tp, _Alloc>::_Node* std::__cxx11::list<_Tp, _Alloc>::_M_create_node(_Args&& ...) [with _Args = {const char*, const char*}; _Tp = argparse::Argument; _Alloc = std::allocator<argparse::Argument>; std::__cxx11::list<_Tp, _Alloc>::_Node = std::_List_node<argparse::Argument>]’
/usr/include/c++/8/bits/list.tcc:92:9:   required from ‘std::__cxx11::list<_Tp, _Alloc>::iterator std::__cxx11::list<_Tp, _Alloc>::emplace(std::__cxx11::list<_Tp, _Alloc>::const_iterator, _Args&& ...) [with _Args = {const char*, const char*}; _Tp = argparse::Argument; _Alloc = std::allocator<argparse::Argument>; std::__cxx11::list<_Tp, _Alloc>::iterator = std::_List_iterator<argparse::Argument>; std::__cxx11::list<_Tp, _Alloc>::const_iterator = std::_List_const_iterator<argparse::Argument>]’
include/argparse.hpp:415:10:   required from ‘argparse::Argument& argparse::ArgumentParser::add_argument(Targs ...) [with Targs = {const char*, const char*}]’
include/argparse.hpp:384:66:   required from here
/usr/include/c++/8/ext/new_allocator.h:136:4: error: no matching function for call to ‘argparse::Argument::Argument(const char*, const char*)’
  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from main.cpp:7:
include/argparse.hpp:103:12: note: candidate: ‘template<long unsigned int N, long unsigned int ...I> argparse::Argument::Argument(std::__cxx11::string (&&)[N], std::index_sequence<I ...>)’
   explicit Argument(std::string(&&a)[N], std::index_sequence<I...>)
            ^~~~~~~~
include/argparse.hpp:103:12: note:   template argument deduction/substitution failed:
In file included from /usr/include/x86_64-linux-gnu/c++/8/bits/c++allocator.h:33,
                 from /usr/include/c++/8/bits/allocator.h:46,
                 from /usr/include/c++/8/string:41,
                 from /usr/include/c++/8/stdexcept:39,
                 from /usr/include/c++/8/array:39,
                 from /usr/include/c++/8/tuple:39,
                 from /usr/include/c++/8/functional:54,
                 from include/argparse.hpp:33,
                 from main.cpp:7:
/usr/include/c++/8/ext/new_allocator.h:136:4: note:   mismatched types ‘std::__cxx11::string [N]’ and ‘const char*’
  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from main.cpp:7:
include/argparse.hpp:97:7: note: candidate: ‘argparse::Argument::Argument(const argparse::Argument&)’
 class Argument {
       ^~~~~~~~
include/argparse.hpp:97:7: note:   candidate expects 1 argument, 2 provided
include/argparse.hpp:97:7: note: candidate: ‘argparse::Argument::Argument(argparse::Argument&&)’
include/argparse.hpp:97:7: note:   candidate expects 1 argument, 2 provided
